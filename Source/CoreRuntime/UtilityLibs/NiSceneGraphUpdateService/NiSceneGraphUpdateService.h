// EMERGENT GAME TECHNOLOGIES PROPRIETARY INFORMATION
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement with Emergent Game Technologies and may not
// be copied or disclosed except in accordance with the terms of that
// agreement.
//
//      Copyright (c) 1996-2009 Emergent Game Technologies.
//      All Rights Reserved.
//
// Emergent Game Technologies, Calabasas, CA 91302
// http://www.emergent.net

#ifndef NIEMERGESERVICE_H
#define NIEMERGESERVICE_H

#include "NiSceneGraphUpdateServiceLibType.h"
#include "NiSceneGraphUpdateMessage.h"
#include "NiSceneGraphUpdateObject.h"

#include <NiTMap.h>
#include <NiString.h>

#include <efd/Asserts.h>
#include <efd/Ids.h>
#include <efd/ISystemService.h>
#include <efd/MessageHandlerBase.h>
#include <efd/MessageService.h>

EE_DECLARE_EXTERNAL_SYSTEMSERVICE_ID(kCLASSID_NiSceneGraphUpdateService, 0x06100001);

/**
    Hooks NiSceneGraphUpdate object into ServiceManager framework.

    This service is used as a bridge between the NiSceneGraphUpdate singleton and
    the MessageService service used to send and receive objects across the network.

    In addition, this class is responsible for establishing the logical connection (beyond simple
    network connectivity between editor and viewer by sending initial connection messages.

    A NiSceneGraphUpdateService object is created automatically by the NiViewerSceneGraphUpdate
    and NiEditorSceneGraphUpdate objects.
*/
class NISCENEGRAPHUPDATESERVICE_ENTRY NiSceneGraphUpdateService : public efd::ISystemService
{
    /// @cond EMERGENT_INTERNAL
    EE_DECLARE_CLASS1(
        NiSceneGraphUpdateService,
        kCLASSID_NiSceneGraphUpdateService,
        efd::ISystemService);
    EE_DECLARE_CONCRETE_REFCOUNT;
    /// @endcond

public:
    /**
        Initialize object

        @param bViewerService Specifies whether this object will be used in a editor or viewer
            application. This changes some behavior like the messages that can be sent by the
            service and how it identifies itself when it establishes a network connection.
    */
    NiSceneGraphUpdateService(const bool bViewerService);

    /**
        Can the message type be sent by a viewer or editor (as configured in constructor)

        @param eMessage Caller passes in the message type to see if it can be sent by the service.
            This depends on whether the service was initialized as a viewer or editor.
        @return True if it can be sent
    */
    bool CanSendMessage(NiSceneGraphUpdate::MessageType eMessage);

    /**
        Queue message so that it can be sent on the next tick.

        @param eMessage Message type used by handling logic to correctly process message
            after receipt
        @param kObjectId Unique identifier for the update object generated by the caller
        @param pkObject Object that contains serialized scene graph data
        @return True if the message can be sent by the service

    */
    bool Send(NiSceneGraphUpdate::MessageType eMessage, const NiSceneGraphUpdateObjectId& kObjectId,
        NiSceneGraphUpdateObject* pkObject);

    /**
        Callback for standard channel manager messages related to connection and disconnection
        from network.

        @param pkMessage Unserialized message received from the message service
        @param kCategory Not used

    */
    void HandleStandardMessage(const efd::IMessage* pkMessage,
        efd::Category kCategory = efd::kCAT_INVALID);

    /**
        Callback for NiSceneGraphUpdateService specific messages. The majority of these messages
        are handled by the NiSceneGraphUpdateMessage object itself.

        @param pkMessage Unserialized message received from the message service
        @param kCategory Not used
    */
    void HandleMessage(const NiSceneGraphUpdateMessage* pkMessage,
        efd::Category kCategory = efd::kCAT_INVALID);

    /**
        Returns the category to be used by the viewer or editor
    */
    static efd::Category GetPrivateCategory(const bool bViewerService);

    /**
        This method is used by a viewer to connect to an editor at a specific IP address.

        @param pcChannelMgrHost IP address (not host name) of the machine running the editor
        @param usChannelMgrPort Port number
        @return True indicates that a connection will attempted on the next tick
    */
    bool Connect(const char* pcChannelMgrHost, NiUInt16 usChannelMgrPort);

    /// Returns the port number currently used for the network connection
    /// @return If NiSceneGraphUpdate::NI_INVALID_PORT is returned, the port number is not available
    NiUInt16 GetRemotePort();

    /// Returns a message suitable for displaying in a UI indicating current network connection
    /// status.
    inline const char* GetStatusMsg() const;

    /// Returns true if a network connection has been successfully established.
    inline bool IsConnectedToNetwork() const;

    /// Returns true if a connection to an editor has been established.
    inline bool IsConnectedToEditor() const;

protected:
    /// Use reference counting to destroy object
    virtual ~NiSceneGraphUpdateService();

    /// Register dependencies
    efd::SyncResult OnPreInit(efd::IDependencyRegistrar* pDependencyRegistrar);

    /// Subscribe for NiSceneGraphUpdateService messages on the local and remote channels
    virtual efd::AsyncResult OnInit();

    /// Send any pending messages and update connection status
    virtual efd::AsyncResult OnTick();

    /// Unsubscribes from message service
    virtual efd::AsyncResult OnShutdown();

    /// Get the service name.
    virtual const char* GetDisplayName() const;

private:

    bool m_bViewerService;
    bool m_bConnectedToNetwork;
    bool m_bConnectedToEditor;
    char m_acConnectionIPAddress[64];
    char m_acStatusMsg[1024];
#ifndef NISHIPPING
    char m_aacSentMessageStatus[3][256];
    char m_aacReceivedMessageStatus[3][256];
#endif
    NiUInt32 m_uiMessageIndex;
    NiSceneGraphUpdateMessagePtr m_aspMessage[2];

    void UpdateConnectionIPAddress();

    efd::MessageServicePtr m_spMessageService;
};

#include "NiSceneGraphUpdateService.inl"

typedef efd::SmartPointer<NiSceneGraphUpdateService> NiSceneGraphUpdateServicePtr;

#endif // NIEMERGESERVICE_H
